# 分析算法
**分析算法(Algorithm Analysis)** 是计算机科学中研究算法效率与资源消耗的学科，旨在评估算法在不同输入规模下的性能表现，为选择和优化算法提供理论依据。其核心目标是回答两个关键问题:
- **时间效率**：算法执行需要多少时间？
- **空间效率**：算法运行需要多少内存或其他资源？

## RAM模型
《算法导论》介绍了一种 **RAM模型(Random Access Machine，随机存取机)**。它是计算机科学中用于分析算法时间复杂度的一种抽象计算模型。它简化了真实计算机的复杂性，假设所有基本操作(如算术运算、内存访问等)均可在**常数时间**内完成，从而聚焦于算法本身的逻辑效率。
### 核心特点
1. 随机访问内存
- 假设内存是“扁平化”的，访问任意地址的数据耗时相同(与硬盘的顺序访问不同)。
- 例如，读取 A[i] 和 A[j] 的时间相同，无论 i 和 j 的距离多远。
2. 基本操作耗时恒定
- 以下操作均视为**常数时间**操作:
- 算术运算(`+, -, *, /`)
- 逻辑比较(`>, ==, &&`)
- 内存读写(**赋值、访问变量**)
- 控制流(`if`, `for`, `return`等)
3. 单处理器、无并发
- 假设程序按顺序执行，不考虑多线程、缓存或并行计算的影响。
4. 无限内存(理想化)
- 忽略物理内存限制，但实际分析中仍需考虑空间复杂度。
### 为什么使用RAM模型？
- 简化分析：屏蔽硬件差异(如CPU速度、缓存层次)，专注于算法的渐进复杂度。
- 通用性：适用于大多数传统算法(排序、搜索、动态规划等)。
- 理论基准：与图灵机等价，但更贴近编程实践。

用**RAM模型**进行严格的算法分析是极难的，需要的数学技巧和工具很多。如
```rs
pub fn realize<T: Ord>(arr: &mut [T]) {
    for i in 1..arr.len() {
        let mut j = i;
        while j > 0 && arr[j] < arr[j - 1] {
            arr.swap(j, j - 1);
            j -= 1;
        }
    }
}
```
我们以 \\(c_i\\) 表示每个操作的代价。

```rs
pub fn realize<T: Ord>(arr: &mut [T]) {
    for i in 1..arr.len() {                     // 代价: c_1
        let mut j = i;                          // 代价: c_2
        while j > 0 && arr[j] < arr[j - 1] {    // 代价: c_3
            arr.swap(j, j - 1);                 // 代价: c_4
            j -= 1;                             // 代价: c_5
        }
    }
}
```
