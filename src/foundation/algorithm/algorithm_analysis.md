# 分析算法
**分析算法(Algorithm Analysis)** 是计算机科学中研究算法效率与资源消耗的学科，旨在评估算法在不同输入规模下的性能表现，为选择和优化算法提供理论依据。其核心目标是回答两个关键问题:
- **时间效率**：算法执行需要多少时间？
- **空间效率**：算法运行需要多少内存或其他资源？

## RAM模型
《算法导论》介绍了一种 **RAM模型(Random Access Machine，随机存取机)**。它是计算机科学中用于分析算法时间复杂度的一种抽象计算模型。它简化了真实计算机的复杂性，假设所有基本操作(如算术运算、内存访问等)均可在**常数时间**内完成，从而聚焦于算法本身的逻辑效率。
### 核心特点
1. **随机访问内存**
    - 假设内存是“扁平化”的，访问任意地址的数据耗时相同(与硬盘的顺序访问不同)。
    - 例如，读取 A[i] 和 A[j] 的时间相同，无论 i 和 j 的距离多远。

2. **基本操作耗时恒定**
    - 算术运算(`+, -, *, /`)
    - 逻辑比较(`>, ==, &&`)
    - 内存读写(**赋值、访问变量**)
    - 控制流(`if`, `for`, `return`等)

以上操作均视为**常数时间**操作。

3. **单处理器、无并发**
    - 假设程序按顺序执行，不考虑多线程、缓存或并行计算的影响。

4. **无限内存(理想化)**
    - 忽略物理内存限制，但实际分析中仍需考虑空间复杂度。

### 为什么使用RAM模型？
- 简化分析：屏蔽硬件差异(如CPU速度、缓存层次)，专注于算法的渐进复杂度。
- 通用性：适用于大多数传统算法(排序、搜索、动态规划等)。
- 理论基准：与图灵机等价，但更贴近编程实践。

用**RAM模型**进行严格的算法分析是极难的，需要的数学技巧和工具很多。如:
```rs
pub fn realize<T: Ord>(arr: &mut [T]) {
    for i in 1..arr.len() {
        let mut j = i;
        while j > 0 && arr[j] < arr[j - 1] {
            arr.swap(j, j - 1);
            j -= 1;
        }
    }
}
```
我们以 \\(c_i\\) 表示每个操作的代价。

```rs
pub fn realize<T: Ord>(arr: &mut [T]) {
    for i in 1..arr.len() {                     // 代价: c_1
        let mut j = i;                          // 代价: c_2
        while j > 0 && arr[j] < arr[j - 1] {    // 代价: c_3
            arr.swap(j, j - 1);                 // 代价: c_4
            j -= 1;                             // 代价: c_5
        }
    }
}
```

> **注**: 下面要使用求和知识，可参见 [附录](/appendices/summation/summation.md)。

每个代价在循环条件都有不同次数的消耗，通过数学分析可以得到:
```rs
// 先给定 n = arr.len()
pub fn realize<T: Ord>(arr: &mut [T]) {
    for i in 1..arr.len() {                     // 次数: n - 1
        let mut j = i;                          // 次数: n - 1
        // 考虑到下面的评估次数受到数组的实际影响，我们简单表达:
        // 设 t_i 为本次内循环中while条件的评估次数
        // 要注意: 内循环的评估次数并不代表消耗次数，因为其要受到外循环的影响
        while j > 0 && arr[j] < arr[j - 1] {    // 次数: \sum_{i=1}^{n-1} t_i
            arr.swap(j, j - 1);                 // 次数: \sum_{i=1}^{n-1} (t_i - 1)
            j -= 1;                             // 次数: \sum_{i=1}^{n-1} (t_i - 1)
        }
        // 注: t_i在最优情况下为1(数组已排序)，在最坏情况下为i+1(数组恰为倒序排序)
    }
}
```
每一步操作的实际消耗是代价乘上对应的次数，我们用 \\(T\\) 代表一个算法(或操作)运行时间，同时对这种形式我们加之 `n` 等参数使表示更为精准(\\(t_i\\)对于输入情况的解释非常复杂，)，那么有:
\\[
T(n) = c_1 (n - 1)  + c_2 (n - 1) + c_3 (\sum_{i=1}^{n-1} t_i) + c_4 (\sum_{i=1}^{n-1} (t_i - 1)) + c_5 (\sum_{i=1}^{n-1} (t_i - 1))
\\]
接着我们代入`t_i`最值，于是有:

**最优情况**:
\\[
T(n) = c_1 (n - 1)  + c_2 (n - 1) + c_3 (n - 1) = (c_1 + c_2 + c_3) n + (c_1 + c_2 + c_3)
\\]
观察后可以发现，\\(c_i\\)属于基本操作，所以 \\((c_1 + c_2 + c_3)\\) 是常数，不难得 \\(T(n)\\) 是关于 \\(n\\) 的**线性函数**[^note1]。

**最坏情况**:
最坏情况下，注意到
\\[
\sum_{i=1}^{n-1} t_i = \sum_{i=1}^{n-1} (i + 1) = \frac{n(n+1)}{2} - 1
\\]
和
\\[
\sum_{i=1}^{n-1} (t_i - 1) = \sum_{i=1}^{n-1} i = \frac{n(n-1)}{2}
\\]
同样我们代入变形:
\\[
T(n) = \frac{c_3 + c_4 + c_5}{2}n^2 + \left(c_1 + c_2 + \frac{c_3 - c_4 - c_5}{2}\right)n - \left(c_1 + c_2 + c_3 - \frac{c_4 + c_5}{2}\right)
\\]
很显然，这是一个**二次函数**。


[^note1]: 这里的线性函数并不是高等数学中的严格定义。《算法导论》中，使用的是初等数学中的宽松定义(即形如 \\(f(x) = kx + b\\) 的一次函数)。对于高等数学来说，上面的函数既不满足齐次性，又不满足叠加性(当\\((c_1 + c_2 + c_3)\\)为0时，原函数变化成零函数，满足线性要求，但显然不为0)。由于\\(b = c_1 + c_2 + c_3 \neq 0 \\)所以该函数更准确的叫**仿射函数**。
