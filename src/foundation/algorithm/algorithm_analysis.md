# 分析算法
**分析算法(Algorithm Analysis)** 是计算机科学中研究算法效率与资源消耗的学科，旨在评估算法在不同输入规模下的性能表现，为选择和优化算法提供理论依据。其核心目标是回答两个关键问题:
- **时间效率**：算法执行需要多少时间？
- **空间效率**：算法运行需要多少内存或其他资源？

## RAM模型
《算法导论》介绍了一种 **RAM模型(Random Access Machine，随机存取机)**。它是计算机科学中用于分析算法时间复杂度的一种抽象计算模型。它简化了真实计算机的复杂性，假设所有基本操作(如算术运算、内存访问等)均可在**常数时间**内完成，从而聚焦于算法本身的逻辑效率。
### 核心特点
1. **随机访问内存**
    - 假设内存是“扁平化”的，访问任意地址的数据耗时相同(与硬盘的顺序访问不同)。
    - 例如，读取 A[i] 和 A[j] 的时间相同，无论 i 和 j 的距离多远。

2. **基本操作耗时恒定**

以下操作均视为**常数时间**操作:
    - 算术运算(`+, -, *, /`)
    - 逻辑比较(`>, ==, &&`)
    - 内存读写(**赋值、访问变量**)
    - 控制流(`if`, `for`, `return`等)

3. **单处理器、无并发**
    - 假设程序按顺序执行，不考虑多线程、缓存或并行计算的影响。

4. **无限内存(理想化)**
    - 忽略物理内存限制，但实际分析中仍需考虑空间复杂度。

### 为什么使用RAM模型？
- 简化分析：屏蔽硬件差异(如CPU速度、缓存层次)，专注于算法的渐进复杂度。
- 通用性：适用于大多数传统算法(排序、搜索、动态规划等)。
- 理论基准：与图灵机等价，但更贴近编程实践。

用**RAM模型**进行严格的算法分析是极难的，需要的数学技巧和工具很多。如:
```rs
pub fn realize<T: Ord>(arr: &mut [T]) {
    for i in 1..arr.len() {
        let mut j = i;
        while j > 0 && arr[j] < arr[j - 1] {
            arr.swap(j, j - 1);
            j -= 1;
        }
    }
}
```
我们以 \\(c_i\\) 表示每个操作的代价。

```rs
pub fn realize<T: Ord>(arr: &mut [T]) {
    for i in 1..arr.len() {                     // 代价: c_1
        let mut j = i;                          // 代价: c_2
        while j > 0 && arr[j] < arr[j - 1] {    // 代价: c_3
            arr.swap(j, j - 1);                 // 代价: c_4
            j -= 1;                             // 代价: c_5
        }
    }
}
```

> **注**: 下面要使用求和知识，可参见 [附录](/appendices/summation/summation.md)。

每个代价在循环条件都有不同次数的消耗，通过数学分析可以得到:
```rs
// 先给定 n = arr.len()
pub fn realize<T: Ord>(arr: &mut [T]) {
    for i in 1..arr.len() {                     // 次数: n - 1
        let mut j = i;                          // 次数: n - 1
        // 考虑到下面的评估次数受到数组的实际影响，我们简单表达:
        // 设 t_i 为本次内循环中while条件的评估次数
        // 要注意: 内循环的评估次数并不代表消耗次数，因为其要受到外循环的影响
        while j > 0 && arr[j] < arr[j - 1] {    // 次数: \sum_{i=1}^{n-1} t_i
            arr.swap(j, j - 1);                 // 次数: \sum_{i=1}^{n-1} (t_i - 1)
            j -= 1;                             // 次数: \sum_{i=1}^{n-1} (t_i - 1)
        }
        // 注: t_i在最优情况下为1，在最坏情况下为i+1
    }
}
```
每一步操作的实际消耗是代价乘上对应的次数，我们用 \\(T\\) 代表一个算法(或操作)运行时间(对于常数时间，我们简单的认为它是"单位1")，同时对这种形式我们加之 `n` 等参数使表示更为精准(\\(t_i\\)对于输入情况的解释非常复杂，这些特殊的参数决定了一个算法的最优最坏和平均情况)，那么有:
\\[
T(n) = c_1 (n - 1)  + c_2 (n - 1) + c_3 (\sum_{i=1}^{n-1} t_i) + c_4 (\sum_{i=1}^{n-1} (t_i - 1)) + c_5 (\sum_{i=1}^{n-1} (t_i - 1))
\\]
