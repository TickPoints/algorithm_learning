# 渐近符号
我们来回顾一下什么是时间复杂度，这是一个特殊的概念，用来形式化的解释一个算法所需要的运行时间与输入规模的特定条件下的映射关系。其中特定条件就是在之前的课程中所描述的最坏，最优，平均等条件。用数学语言表达来看:
$$T(n)$$
其中，$T$表示最终的运行时间，$n$表示输入规模，通过一些额外标记，如$T_\text{最坏情况}(n)$来表述特定情况。

**在数学中，渐近(Asymptotic) 描述的是函数或序列在某个极限点附近的行为趋势。**

$T(n)$本身就是一个函数，当$n \to \infty$时，可能会无限接近另外一个函数或方程，对其的分析，便是数学上的渐近分析。即分析当自变量趋近于某个极限时，函数或序列如何逼近某个特定的值、曲线或增长模式，而不一定严格达到它。

这也是我们为什么需要渐近分析的理由，它帮助我们在面对一个足够大的数据规模(数据规模一般为自然数)时，仍能较好的对算法的运行时间进行估计。我们来回顾已经遇到过的两个渐近符号: $\Theta$和$O$，它们本质上是作用于函数的。我们先将这个$T(n)$所逼近的函数记作$g(n)$，对于$T(n)$来说，这两种渐进符号就是与$g(n)$和其自身有关的集合，即$T(n) \in \Theta(g(n))$(所以前文说$=$是非形式化的)。

既然如此，那让我们来对这个集合做正式定义:

## $\Theta$ 记号
$$
\Theta(g(n)) = \{ f(n) | \exists c_1, c_2 > 0, n_0 > 0 : \forall n \geq n_0, 0 \leq c_1 g(n) \leq f(n) \leq c_2 g(n) \}
$$
$\Theta$ 是本书中常用的渐近符号，我们来分析一下这个定义:
- $f(x)$是这个记号所代表集合的成员，例如我们之前用的$T(n)$。
- 条件是: 存在正常量$c_1, c_2$和$n_0$，使得所有的$n > n_0$有$0 \leq c_1 g(n) \leq f(n) \leq c_2 g(n)$。其中$n_0$是一个临界值，这个临界值之后(包括自身)的所有$n$都满足渐近关系。

在这里我们通过两个系数正常量$c_1, c_2$，控制两个$g(n)$使得这两个$g(n)$把$f(n)$夹在中间。反着来说，如果$f(n)$在$n_0$之后被夹在$c_1 \cdot g(n)$和$c_2 \cdot g(n)$中，那么$f(n) \in \Theta(g(n))$，并称$g(n)$是$f(n)$的 **渐近紧确(上下)界(Asymptotic Tight Bound)**，简称 **(紧)确界**。

```mermaid
xychart-beta
    title "紧确上下界示例"
    x-axis 0 --> 30
    y-axis 0 --> 80
    line [3, 0, 7, 8, 16, 32, 64, 128]
    line [2, 4, 6, 8, 10, 12, 14, 16]
    line [1, 10, 9, 8, 7, 6, 5, 4]
```

在上面这个图例中，起点为$2$的函数为$f(x)$，$1$函数为$c_1 g(n)$，$3$的函数为$c_1 g(n)$。在$y = 8$前面它们的大小很难看出规律，在$y = 8$之后显现出$c_1 g(n) \leq f(n) \leq c_2 g(n)$，此时$n = 13$。所以$n_0 = 13$时，$f(x) = \Theta(g(n))$，这个时候夹逼的两个系数为$c_1, c_2$。

在[分析算法](foundation/algorithm/algorithm_analysis.md#练习与回答)一节中，我们发现**最高阶项决定一切**，从而将一个函数转化为关于$\Theta$渐近形式，这在直觉上是对的，不过现在我们要来证明:

假设，我们的想法是对的，那么，对于$\frac{n ^ 3}{1000} - 100n ^ 2 - 100n + 3$
$$
c_1 n ^ 3 < \frac{n ^ 3}{1000} - 100n ^ 2 - 100n + 3 < c_2 n ^ 3
$$
用$n ^ 3$除以上式得:
$$
c_1 < \frac{1}{1000} - \frac{100}{n} - \frac{100}{n ^ 2} + \frac{100}{n ^ 3} < c_2
$$
对于上面的$\frac{1}{1000} - \frac{100}{n} - \frac{100}{n ^ 2} + \frac{100}{n ^ 3}$变形，得$\frac{1}{1000} - 100 \left(\frac{n ^ 2 + n - 1}{n ^ 3} \right)$。

因为$n \in \mathbb{N}$，所以上式最大肯定无法到达$\frac{1}{1000}$，可以让$c_2 = \frac{1}{1000}$。

接着想要找到一个不小于零的最小值，由于该式的特殊性，这一步比较难，设$f(x) = \frac{1}{1000} - \frac{100}{n} - \frac{100}{n ^ 2} + \frac{100}{n ^ 3}$，可利用计算机求得: $f(100000) \approx −0.0000000099$，$f(100001) \approx 0.0000000000003$，所以可以让$c_1 = 10 ^ {-13}$。

所以，现在选择$c_1 = 10 ^ {-13}$，$c_2 = \frac{1}{1000}$，$n_0 = 100001$即可证明$\frac{n ^ 3}{1000} - 100n ^ 2 - 100n + 3 = \Theta(n)$。

利用反证法，我们也可以证明$6 n^3 \neq \Theta(n ^ 2)$: 假设存在$c_2$和$n$，使得对所有$n \geq n_0$，有$6 n^3 \leq c_2 n ^ 2$。然而用$n ^ 2$除该式，得$n \leq \frac{c}{6}$，因为$c$为常量，所以对任意大的$n$，该不等式不可能总成立。

上面的仅作为例子，对于任意二次函数的证明可以参考[练习与回答](#练习与回答)。

照这样，我们也可以把其他的记号都定义出来:

## $O$ 记号
$O$ 记号在历史上出现的最早，也最为常用(因为不需要像$\Theta$同时保证一个下界，因此更方便无需更复杂的数学证明)。
$$
O(g(n)) = \{ f(x) | \exists c > 0, \exists n_0 \in \mathbb{N}, \forall n \geq n_0, \, |f(n)| \leq c \cdot |g(n)| \}
$$

在定义下一个记号之前让我们先缓一下，在[二分查找](/foundation/algorithm/binary_search.md)一节中我们提到了下面这个问题:

在上述算法中，插入排序可以在$\Theta(n k)$时间内排序每个长度为$k$的$n / k$个子表(每个子表排序的时间复杂度为$\Theta(k ^ 2)$，故$T(n) = \Theta(k ^ 2) \cdot (n / k) = \Theta(n k)$)。同样不难看出，合并子表的时间复杂度是$\Theta(n \log (n / k))$，综上就有该算法最坏情况下的时间复杂度为$\Theta(n k + n \log (n / k))$。为了确保任何$k$的取值不能使修改后算法时间复杂度高于原算法，$k = O(\log n)$。

> [!WARNING]
> 该章节仍在编写，欢迎在 [GitHub仓库](https://github.com/TickPoints/algorithm_learning) 提交PR贡献内容。

---
## 练习与回答
> [!WARNING]
> 该章节仍在编写，欢迎在 [GitHub仓库](https://github.com/TickPoints/algorithm_learning) 提交PR贡献内容。
